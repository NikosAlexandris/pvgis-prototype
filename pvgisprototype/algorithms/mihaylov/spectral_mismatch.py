from pvgisprototype.log import logger
from pvgisprototype.api.irradiance.kato_bands import KATO_BANDS
from xarray import apply_ufunc
from numpy import interp, isfinite, nan_to_num
from scipy.integrate import simpson
from pvgisprototype.algorithms.mihaylov.interpolate import interpolate_spectral_data


def calculate_spectral_mismatch_factor_mihaylow(
    irradiance,
    average_irradiance_density,
    responsivity,
    reference_spectrum,
    # spectral_band_wavelengths_for_banding = None,
):
    """Calculate the spectral mismatch factor

    The spectral mismatch factor is the ratio of photovoltaic power generated by a solar module under actual conditions compared to standard reference conditions.

    responsivity :

    reference_spectrum :
        A standardised solar irradiance spectrum, defaults to the AM1.5G spectrum 
    
    Notes
    -----

    The `reference_spectrum` represents a standardised solar irradiance
    spectrum or else the expected irradiance under reference conditions. It
    defaults to the AM1.5G spectrum used for standardized testing of
    photovoltaic modules. Nonetheless, a user may define another reference
    spectrum.

    """
    # Preparatory steps --- Push Me Upstream ?

    ## Prepare Reference Spectrum

    reference_spectrum = reference_spectrum.to_xarray().fillna(0.0)
    # reference_spectrum = reference_spectrum.where(isfinite(reference_spectrum), 0.0)
    logger.info(
        f'Reference spectrum input :\n{reference_spectrum}',
        alt=f'[bold]Reference spectrum input[/bold] :\n{reference_spectrum}'
    )

    # Responsivity -----------------------------------------------------------

    # Push me upstream ? -----------------------------------------------------
    if 'Center [nm]' in responsivity.coords:
        responsivity = responsivity.rename({'Center [nm]': 'wavelength'})
    else:
        responsivity = responsivity.rename({'Wavelength': 'wavelength'})

    logger.info(
        f'Spectral Responsivity input :\n{responsivity}',
        alt=f'[green]Spectral Responsivity[/green] input :\n{responsivity}',
    )

    ## Expand responsivity wavelengths to cover the reference spectrum !

    reference_responsivity = responsivity.reindex(
        wavelength=reference_spectrum.wavelength, fill_value=0
    )
    logger.info(
        f"Expanded spectral responsivity to match reference spectrum :\n{reference_responsivity}",
        alt=f"[yellow]Expanded [/yellow] [green]spectral responsivity[/green] to match the reference spectrum :\n{reference_responsivity}"
    )

    ## Interpolate Spectral Responsivity to match the Reference Spectrum

    reference_responsivity = interpolate_spectral_data(
            data=reference_responsivity,
            reference_wavelengths=reference_spectrum.wavelength,
            data_name='Reference Responsivity',
            )
    logger.info(
            f"Interpolated spectral responsivity data :\n{reference_responsivity}",
            alt=f"[yellow]Interpolated[/yellow] [green]spectral responsivity[/green] data :\n{reference_responsivity}",
            )

    # Reference Spectrum -----------------------------------------------------

    # Total Reference Spectrum

    total_reference_energy = simpson(
        y=reference_spectrum["global"],
        x=reference_spectrum.wavelength,
    )
    logger.info(
        f"Total energy from the reference spectrum over the relevant wavelength range : {total_reference_energy}",
        alt=f"[bold]Total energy from the reference spectrum[/bold] over the relevant wavelength range : {total_reference_energy}",
    )

    # Current Density of Reference Spectrum
    current_density_of_reference_spectrum = reference_spectrum * reference_responsivity
    logger.info(
            f"Current density of Reference Spectrum :\n{current_density_of_reference_spectrum}",
            alt=f"[bold]Current density of Reference Spectrum[/bold] :\n{current_density_of_reference_spectrum}"
            )

    # Useful Reference Spectrum
    useful_reference_spectrum = simpson(
        y=current_density_of_reference_spectrum['global'],
        x=reference_spectrum.wavelength
        # x=common_wavelengths
    )
    logger.info(
            f"Useful reference spectrum : {useful_reference_spectrum}",
            alt=f"[bold][yellow]Useful[/yellow] reference spectrum[/bold] : {useful_reference_spectrum}"
            )

    # Observed Irradiance ----------------------------------------------------

    ## Get scalar boundary conditions for the left and right
    left_value = float(average_irradiance_density.isel(center_wavelength=0).mean())
    right_value = 0  # Scalar value for the right boundary
    
    ## Interpolate Observed Irradiance to Reference Spectrum

    interpolated_observed_irradiance = apply_ufunc(
        interp,
        reference_spectrum.wavelength,            # The target wavelength grid
        average_irradiance_density.center_wavelength,            # The current wavelength grid (Kato bands)
        average_irradiance_density,                  # The irradiance data to be interpolated (2D array: time Ã— Kato bands)
        vectorize=True,                   # Allow vectorization over time dimension
        input_core_dims=[['wavelength'], ['center_wavelength'], ['center_wavelength']],
        output_core_dims=[['wavelength']],
        dask="allowed",                   # Parallelize with Dask if available
        kwargs={"left": left_value, "right": right_value}
    ).fillna(0.0)
    # interpolated_observed_irradiance = interpolated_observed_irradiance.where(
    #     isfinite(interpolated_observed_irradiance), 0.0
    # )
    logger.info(
            f"Interpolated irradiance :\n{interpolated_observed_irradiance}",
            alt=f"[bold][yellow]Interpolated[/yellow] irradiance[/bold] :\n{interpolated_observed_irradiance}",
            )

    # Total Observed Irradiance 

    # Should include all bands up to ~4K nm

    # Integration over the wavelength axis (axis=1 for 2D data)

    # Note -------------------------------------------------------------------
    # Performing numerical integration over the wavelength axis using simpson
    # will typically collapse the axis in question and result in a scalar along
    # non-integrated dimensions.
    # ------------------------------------------------------------------------

    total_observed_interpolated_observed_irradiance = simpson(
        y=interpolated_observed_irradiance,
        x=reference_spectrum.wavelength,
        axis=1,  # integrate over wavelength axis
    )
    total_observed_interpolated_observed_irradiance = nan_to_num(total_observed_interpolated_observed_irradiance)
    # total_observed_interpolated_observed_irradiance = total_observed_interpolated_observed_irradiance.where(isfinite(total_observed_interpolated_observed_irradiance), 0.0)

    # Does length of x match the second dimension of y ?
    if reference_spectrum.wavelength.shape[0] != interpolated_observed_irradiance.shape[1]:
        raise ValueError("Wavelength dimension does not match the interpolated irradiance data shape.")

    logger.info(
            f"Total Observed Reference Irradiance :\n{total_observed_interpolated_observed_irradiance}",
            alt=f"[bold]Total Observed Reference Irradiance[/bold] :\n{total_observed_interpolated_observed_irradiance}"
            )

    # Current Density of Observed Irradiance
    current_density_of_observed_interpolated_observed_irradiance = interpolated_observed_irradiance * reference_responsivity
    logger.info(
            f"Current density of Observed Irradiance :\n{current_density_of_reference_spectrum}",
            alt=f"[yellow][bold]Current density[/bold] of Observed Irradiance[/yellow] :\n{current_density_of_reference_spectrum}"
            )
    useful_observed_irradiance = simpson(
        y=current_density_of_observed_interpolated_observed_irradiance,
        x=reference_spectrum.wavelength,
        axis=1,
    )
    logger.info(
            f"Useful observed irradiance: {useful_observed_irradiance}",
            alt=f"[bold][yellow]Useful[/yellow] observed irradiance[/bold] :\n{useful_observed_irradiance}"
            )

    # Spectral Mismatch Factor
    a = useful_observed_irradiance / useful_reference_spectrum
    # epsilon = 1e-10  # Small constant to avoid division by zero
    # b = total_reference_energy / (total_observed_interpolated_observed_irradiance + epsilon)
    b = total_reference_energy / total_observed_interpolated_observed_irradiance

    return a * b
