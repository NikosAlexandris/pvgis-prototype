import csv
from pathlib import Path
import re
from typing import Dict
from pandas import DatetimeIndex, Timestamp

from numpy import full, ndarray

from pvgisprototype.api.power.photovoltaic_module import PhotovoltaicModuleType
from pvgisprototype.api.utilities.conversions import round_float_values
from pvgisprototype.constants import (
    SPECTRAL_FACTOR_COLUMN_NAME,
    ALTITUDE_COLUMN_NAME,
    ALTITUDE_NAME,
    AZIMUTH_COLUMN_NAME,
    AZIMUTH_NAME,
    DECLINATION_COLUMN_NAME,
    DECLINATION_NAME,
    FINGERPRINT_COLUMN_NAME,
    HOUR_ANGLE_COLUMN_NAME,
    HOUR_ANGLE_NAME,
    INCIDENCE_COLUMN_NAME,
    INCIDENCE_NAME,
    LATITUDE_COLUMN_NAME,
    LONGITUDE_COLUMN_NAME,
    NOT_AVAILABLE,
    POSITION_ALGORITHM_COLUMN_NAME,
    POSITION_ALGORITHM_NAME,
    ROUNDING_PLACES_DEFAULT,
    SHADING_STATES_COLUMN_NAME,
    SUN_HORIZON_POSITIONS_NAME,
    SURFACE_ORIENTATION_COLUMN_NAME,
    SURFACE_ORIENTATION_NAME,
    SURFACE_TILT_COLUMN_NAME,
    SURFACE_TILT_NAME,
    TIME_ALGORITHM_COLUMN_NAME,
    TIME_ALGORITHM_NAME,
    UNIT_NAME,
    UNITLESS,
    UNITS_COLUMN_NAME,
    ZENITH_COLUMN_NAME,
    ZENITH_NAME,
)
def safe_get_value(dictionary, key, index, default=NOT_AVAILABLE):
    """
    Parameters
    ----------
    dictionary: dict
        Input dictionary
    key: str
        key to retrieve from the dictionary
    index: int
        index ... ?

    Returns
    -------
    The value corresponding to the given `key` in the `dictionary` or the
    default value if the key does not exist.

    """
    value = dictionary.get(key, default)
    # if isinstance(value, ndarray) and value.size > 1:
    if isinstance(value, (list, ndarray)) and len(value) > index:
        return value[index]
    return value


def export_statistics_to_csv(data_array, filename):
    statistics = calculate_series_statistics(data_array)
    with open(f"{filename}.csv", "w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["Statistic", "Value"])
        for statistic, value in statistics.items():
            writer.writerow([statistic, value])


def write_irradiance_csv(
    longitude: float = None,
    latitude: float = None,
    timestamps: list = [],
    dictionary: dict = {},
    index: bool = False,
    filename: Path = Path("irradiance.csv"),
) -> None:
    """
    Write time series data to a CSV file in a structured format.

    This function takes location information (longitude and latitude), a time
    series (timestamps), and a dictionary containing irradiance or photovoltaic
    power data, generated by PVGIS' API functions, and writes them into a CSV
    file.

    Attention ! The function modifies the input dictionary by removing certain
    keys (such as 'Title' and 'Fingerprint') to avoid repeated values in the
    output file. It is essential to place this function last in the workflow if
    the original dictionary is needed elsewhere in the code, as it alters the
    input dictionary in place to save memory.

    Parameters
    ----------
    longitude : float, optional
        Longitude of the location to include in the CSV output.
    
    latitude : float, optional
        Latitude of the location to include in the CSV output.
    
    timestamps : list, optional
        A Pandas DatetimeIndex. Each timestamp will correspond to a row in the
        CSV file.
    
    dictionary : dict
        A dictionary containing the irradiance or photovoltaic data, where 
        each key is a variable name and each value is either a list/array of 
        data or a single value to be replicated for all timestamps.
    
    index : bool, optional
        If True, an index column will be added to the CSV file, where each 
        row will be numbered sequentially.
    
    filename : Path, optional
        The output file path where the CSV will be saved. Defaults to 
        "irradiance.csv".
    
    Notes
    -----
    - The function is optimized to avoid deep copying the dictionary, 
      reducing memory consumption. It should be placed at the end of any 
      process that requires the original dictionary to remain unmodified.

    - Fingerprint information is removed from the input dictionary and added 
      as part of the filename.
    
    - Single float or integer values in the dictionary are expanded to match 
      the length of the timestamps.
    
    - This function expects the `photovoltaic_power_output_series.components` 
      structure to match the format required for writing to CSV.

    Example
    -------
    >>> write_irradiance_csv(
            longitude=-3.7038,
            latitude=40.4168,
            timestamps=some_timestamps,
            dictionary=some_data,
            filename=Path("output.csv"),
            index=True
        )

    This will generate a CSV file named 'output.csv' with the specified 
    data and location.
    """
    # remove 'Title' and 'Fingerprint' : we don't want repeated values ! ----
    dictionary.pop("Title", NOT_AVAILABLE)
    fingerprint = dictionary.pop(FINGERPRINT_COLUMN_NAME, None)
    if not fingerprint:
        fingerprint = Timestamp.now().isoformat(timespec="seconds")
        # Sanitize the ISO datetime for a safe filename
    safe_fingerprint = re.sub(r"[:]", "-", fingerprint)  # Replace colons with hyphens
    safe_fingerprint = safe_fingerprint.replace(" ", "T")  # Ensure ISO format with 'T'
    # remove 'Sun Horizon Positions' : we don't need a list of possible options !
    sun_horizon_positions = dictionary.pop(SUN_HORIZON_POSITIONS_NAME, NOT_AVAILABLE)
    shading_states = dictionary.pop(SHADING_STATES_COLUMN_NAME, NOT_AVAILABLE)
    # ------------------------------------------------------------- Important

    header = []
    if index:
        header.insert(0, "Index")
    if longitude:
        header.append("Longitude")
    if latitude:
        header.append("Latitude")

    header.append("Time")
    header.extend(dictionary.keys())

    # Convert single float or int values to arrays of the same length as timestamps
    for key, value in dictionary.items():
        if isinstance(value, (float, int)):
            dictionary[key] = full(len(timestamps), value)
        if isinstance(value, str):
            dictionary[key] = full(len(timestamps), str(value))
        if isinstance(value, PhotovoltaicModuleType):
            dictionary[key] = full(len(timestamps), str(value.value))


    # Zip series and timestamps
    zipped_series = zip(*dictionary.values())
    zipped_data = zip(timestamps, zipped_series)

    rows = []
    for idx, (timestamp, values) in enumerate(zipped_data):
        row = []
        if index:
            row.append(idx)
        if longitude and latitude:
            row.extend([longitude, latitude])
        row.append(timestamp.strftime("%Y-%m-%d %H:%M:%S"))
        row.extend(values)
        rows.append(row)

    # Write to CSV
    if fingerprint:
        # use the _safe_ fingerprint !
        filename = filename.with_stem(filename.stem + f"_{safe_fingerprint}")
    with filename.open("w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(header)  # assuming a list of column names
        writer.writerows(rows)  # a list of rows, each row a list of values


def write_solar_position_series_csv(
    longitude,
    latitude,
    timestamps,
    timezone,
    table,
    index: bool = False,
    timing=None,
    declination=None,
    hour_angle=None,
    zenith=None,
    altitude=None,
    azimuth=None,
    surface_orientation=None,
    surface_tilt=None,
    incidence=None,
    user_requested_timestamps=None,
    user_requested_timezone=None,
    rounding_places=ROUNDING_PLACES_DEFAULT,
    group_models: bool = False,
    filename: Path = Path("solar_position.csv"),
):
    # Round values
    longitude = round_float_values(longitude, rounding_places)
    latitude = round_float_values(latitude, rounding_places)
    # rounded_table = round_float_values(table, rounding_places)
    quantities = [declination, zenith, altitude, azimuth, incidence]

    header = []
    if index:
        header.append("Index")
    if longitude is not None:
        header.append(LONGITUDE_COLUMN_NAME)
    if latitude is not None:
        header.append(LATITUDE_COLUMN_NAME)
    if timestamps is not None:
        header.append("Time")
    if timezone is not None:
        header.append("Zone")
    if user_requested_timestamps is not None and user_requested_timezone is not None:
        header.extend(["Local Time", "Local Zone"])
    if timing is not None:
        header.append(TIME_ALGORITHM_COLUMN_NAME)
    if declination is not None:
        header.append(DECLINATION_COLUMN_NAME)
    if hour_angle is not None:
        header.append(HOUR_ANGLE_COLUMN_NAME)
    if any(quantity is not None for quantity in quantities):
        header.append(POSITION_ALGORITHM_COLUMN_NAME)
    if zenith is not None:
        header.append(ZENITH_COLUMN_NAME)
    if altitude is not None:
        header.append(ALTITUDE_COLUMN_NAME)
    if azimuth is not None:
        header.append(AZIMUTH_COLUMN_NAME)
    if incidence is not None:
        header.append(SURFACE_ORIENTATION_COLUMN_NAME)
        header.append(SURFACE_TILT_COLUMN_NAME)
        header.append(INCIDENCE_COLUMN_NAME)
    header.append(UNITS_COLUMN_NAME)
    import re

    header = [re.sub(r"[^A-Za-z0-9 ]+", "", h) for h in header]

    rows = []
    # Iterate over each timestamp and its corresponding result
    for _, model_result in table.items():
        for _index, timestamp in enumerate(timestamps):
            timing_algorithm = safe_get_value(
                model_result, TIME_ALGORITHM_NAME, NOT_AVAILABLE
            )  # If timing is a single value and not a list
            declination_value = (
                safe_get_value(model_result, DECLINATION_NAME, _index)
                if declination
                else None
            )
            hour_angle_value = (
                safe_get_value(model_result, HOUR_ANGLE_NAME, _index)
                if hour_angle
                else None
            )
            position_algorithm = safe_get_value(
                model_result, POSITION_ALGORITHM_NAME, NOT_AVAILABLE
            )
            zenith_value = (
                safe_get_value(model_result, ZENITH_NAME, _index) if zenith else None
            )
            altitude_value = (
                safe_get_value(model_result, ALTITUDE_NAME, _index)
                if altitude
                else None
            )
            azimuth_value = (
                safe_get_value(model_result, AZIMUTH_NAME, _index) if azimuth else None
            )
            surface_orientation = (
                safe_get_value(model_result, SURFACE_ORIENTATION_NAME, _index)
                if surface_orientation
                else None
            )
            surface_tilt = (
                safe_get_value(model_result, SURFACE_TILT_NAME, _index)
                if surface_tilt
                else None
            )
            incidence_value = (
                safe_get_value(model_result, INCIDENCE_NAME, _index)
                if incidence
                else None
            )
            units = safe_get_value(model_result, UNIT_NAME, UNITLESS)

            row = []
            if index:
                row.append(str(_index))
            if longitude:
                row.append(str(longitude))
            if latitude:
                row.append(str(latitude))
            row.extend([str(timestamp), str(timezone)])

            # ---------------------------------------------------- Implement-Me---
            # Convert the result back to the user's time zone
            # output_timestamp = output_timestamp.astimezone(user_timezone)
            # --------------------------------------------------------------------

            # Redesign Me! =======================================================
            if user_requested_timestamps is not None and (
                user_requested_timestamps.tz is None
                and user_requested_timezone is not None
            ):
                user_requested_timestamps = user_requested_timestamps.tz_localize(
                    user_requested_timezone
                )
                row.extend(
                    [
                        str(user_requested_timestamps.get_loc(timestamp)),
                        str(user_requested_timezone),
                    ]
                )
            # =====================================================================

            if timing is not None:
                row.append(timing_algorithm)
            if declination_value is not None:
                row.append(str(declination_value))
            if hour_angle_value is not None:
                row.append(str(hour_angle_value))
            if position_algorithm is not None:
                row.append(position_algorithm)
            if zenith_value is not None:
                row.append(str(zenith_value))
            if altitude_value is not None:
                row.append(str(altitude_value))
            if azimuth_value is not None:
                row.append(str(azimuth_value))
            if incidence_value is not None:
                if surface_orientation is not None:
                    row.append(str(surface_orientation))
                if surface_tilt is not None:
                    row.append(str(surface_tilt))
                row.append(str(incidence_value))
            row.append(str(units))
            rows.append(row)

    with open(filename, "w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(header)
        writer.writerows(rows)



def write_spectral_factor_csv(
    longitude,
    latitude,
    timestamps: DatetimeIndex,
    spectral_factor_dictionary: Dict,
    filename: Path = Path("spectral_factor.csv"),
    index: bool = False,
):
    """
    Write the spectral factor data to a CSV file.

    Parameters
    ----------
    - longitude: Longitude of the location.
    - latitude: Latitude of the location.
    - timestamps: DatetimeIndex of the time series.
    - spectral_factor_dictionary: Dictionary containing spectral factor data.
    - filename: Path for the output CSV file.
    - index: Whether to include the index in the CSV.

    """
    header = []
    if index:
        header.append("Index")
    if longitude:
        header.append("Longitude")
    if latitude:
        header.append("Latitude")
    
    header.append("Time")

    # Prepare the data for each spectral factor model and module type
    data_rows = []
    for spectral_factor_model, result in spectral_factor_dictionary.items():
        for module_type, data in result.items():
            spectral_factor_series = data.get(SPECTRAL_FACTOR_COLUMN_NAME)

            # If spectral_factor_series is a scalar, expand it to match the length of timestamps
            if isinstance(spectral_factor_series, (float, int)):
                spectral_factor_series = full(len(timestamps), spectral_factor_series)

            # Add the header for this particular module type and spectral factor model
            header.append(f"{module_type.value} ({spectral_factor_model.name})")

            # Prepare the rows
            for idx, timestamp in enumerate(timestamps):
                if len(data_rows) <= idx:
                    data_row = []
                    if index:
                        data_row.append(idx)
                    if longitude and latitude:
                        data_row.extend([longitude, latitude])
                    data_row.append(timestamp.strftime("%Y-%m-%d %H:%M:%S"))
                    data_rows.append(data_row)

                # Append spectral factor data for this timestamp and module type
                data_rows[idx].append(spectral_factor_series[idx])

    # Write to CSV
    with filename.open("w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(header)  # Write header
        writer.writerows(data_rows)  # Write rows of data
